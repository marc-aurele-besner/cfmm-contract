// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
/**
 * @title SplitFeeCFMM
 * @author Marc-AurÃ¨le Besner (marc-aurele-besner)
 * @notice SplitFeeCFMM manages DeFi liquidity, tracking accumulated fees per user.
 * This contract implements a Constant Function Market Maker (CFMM) model, with accrued fees and claiming.
 * @dev Core Concepts:
 *      - Liquidity Pool (LP): This contract, where users deposit tokens for trading and liquidity provision.
 *      - Liquidity: Users' capital deposited into the LP.
 *      - Accumulated Fees: Fees generated by the protocol, tracked per user and available to claim.
 *      Actions:
 *      - Add Liquidity: Users provide tokens to the LP and receive pool tokens.
 *      - Remove Liquidity: Users withdraw their tokens from the LP.
 *      - Claim Fees: Users claim accumulated fees accrued from trading activity in the pool.
 *      - Swap: Exchange one token for another via the CFMM.
 *      - Protocol Fee: Portion of trading fees allocated to the protocol.
 *
**/

contract SplitFeeCFMM is ERC20, ReentrancyGuard {
    // Tokens associated with the pair
    address public tokenA;
    address public tokenB;
    // Address of the protocol fee recipient
    address public protocolFeeRecipient;
    // Reserves of the tokens in the pair (amount of tokenA and tokenB in the pool)
    uint256 public reserveA;
    uint256 public reserveB;
    // Fees configuration
    uint256 public constant TOTAL_FEE_BPS = 25;     // 0.25% Total fee (protocol + user)
    uint256 public constant PROTOCOL_FEE_BPS = 5;   // 0.05% Protocol fee
    uint256 public constant MINIMUM_LIQUIDITY = 10**3; // Minimum liquidity required to create a pair (1000 tokens)
    // Fee accumulated in the pool
    uint256 public accumulatedTokenAFeePerShare;
    uint256 public accumulatedTokenBFeePerShare;

    struct UserInfo {
        uint256 rewardDebtA;
        uint256 rewardDebtB;
    }
    
    // Mapping of user to their user info
    mapping(address => UserInfo) public userInfo;

    // Events
    event Swap(
        address indexed sender, 
        uint256 amountAIn, 
        uint256 amountBIn, 
        uint256 amountAOut, 
        uint256 amountBOut, 
        address indexed to
    );
    event Mint(address indexed sender, uint256 amountA, uint256 amountB);
    event Burn(address indexed sender, uint256 amountA, uint256 amountB, address indexed to);
    event Sync(uint256 reserveA, uint256 reserveB);
    event FeesClaimed(address indexed user, uint256 amountA, uint256 amountB);

    constructor(
        address _tokenA, 
        address _tokenB, 
        address _protocolFeeRecipient, 
        uint256 _amountA, 
        uint256 _amountB,
        string memory _pairName,
        string memory _pairSymbol
    ) 
        ERC20(_pairName, _pairSymbol
    ) {
        tokenA = _tokenA;
        tokenB = _tokenB;
        protocolFeeRecipient = _protocolFeeRecipient;

        reserveA = _amountA;
        reserveB = _amountB;

        _mint(address(this), _amountA * _amountB);
        
    }

    function swap(uint256 _amountAOut, uint256 _amountBOut, address _to) external nonReentrant {
    }

    function addLiquidity(address _to) external nonReentrant {
    }

    function removeLiquidity(address _to) external nonReentrant {
    }

    function removeExactLiquidity(uint256 _amount,address _to) external nonReentrant {
    }

    function claimFees() external {
    }

    function getReserves() external view returns (uint256, uint256) {
        return (reserveA, reserveB);
    }

    function getAmountOut(address _tokenIn, uint256 _amountIn) external view returns (uint256) {
    }

    function getProtocolFeeRecipient() external view returns (address) {
        return protocolFeeRecipient;
    }

    function getTokenA() external view returns (address) {
        return tokenA;
    }

    function getTokenB() external view returns (address) {
        return tokenB;
    }

    function getTotalLiquidity() external view returns (uint256) {
        return reserveA * reserveB;
    }

    function getReserveA() external view returns (uint256) {
        return reserveA;
    }

    function getReserveB() external view returns (uint256) {
        return reserveB;
    }

    // Internal functions
    function _swap(uint256 _amountAOut, uint256 _amountBOut, address _to) internal {
    }

    function _addLiquidity(address _to) internal {
    }

    function _removeLiquidity(address _to) internal {
    }

    function _removeExactLiquidity(uint256 _amount,address _to) internal {
    }

    function _claimFees() internal {
    }

    function _sync() internal {
        emit Sync(reserveA, reserveB);
    }
}